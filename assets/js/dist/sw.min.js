---
permalink: /:basename
---
/*!
 * undefined vundefined | Â© undefined undefined | undefined Licensed | undefined
 */
(function () {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: true
            } : {
              done: false,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = true,
      u = false;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = true, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  importScripts('./assets/js/data/swconf.js');
  var purge = swconf.purge;
  var interceptor = swconf.interceptor;
  function verifyUrl(url) {
    var requestUrl = new URL(url);
    var requestPath = requestUrl.pathname;
    if (!requestUrl.protocol.startsWith('http')) {
      return false;
    }
    var _iterator = _createForOfIteratorHelper(interceptor.urlPrefixes),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prefix = _step.value;
        if (requestUrl.href.startsWith(prefix)) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(interceptor.paths),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var path = _step2.value;
        if (requestPath.startsWith(path)) {
          return false;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return true;
  }
  self.addEventListener('install', function (event) {
    if (purge) {
      return;
    }
    event.waitUntil(caches.open(swconf.cacheName).then(function (cache) {
      return cache.addAll(swconf.resources);
    }));
  });
  self.addEventListener('activate', function (event) {
    event.waitUntil(caches.keys().then(function (keyList) {
      return Promise.all(keyList.map(function (key) {
        if (purge) {
          return caches["delete"](key);
        } else {
          if (key !== swconf.cacheName) {
            return caches["delete"](key);
          }
        }
      }));
    }));
  });
  self.addEventListener('message', function (event) {
    if (event.data === 'SKIP_WAITING') {
      self.skipWaiting();
    }
  });
  self.addEventListener('fetch', function (event) {
    if (event.request.headers.has('range')) {
      return;
    }
    event.respondWith(caches.match(event.request).then(function (response) {
      if (response) {
        return response;
      }
      return fetch(event.request).then(function (response) {
        var url = event.request.url;
        if (purge || event.request.method !== 'GET' || !verifyUrl(url)) {
          return response;
        }

        // See: <https://developers.google.com/web/fundamentals/primers/service-workers#cache_and_return_requests>
        var responseToCache = response.clone();
        caches.open(swconf.cacheName).then(function (cache) {
          cache.put(event.request, responseToCache);
        });
        return response;
      });
    }));
  });

})();
