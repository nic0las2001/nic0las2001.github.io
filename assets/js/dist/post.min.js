/*!
 * undefined vundefined | Â© undefined undefined | undefined Licensed | undefined
 */
(function (collapse_js, Tooltip) {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  document.getElementsByClassName('collapse');

  var clipboardSelector = '.code-header>button';
  var ICON_DEFAULT = 'far fa-clipboard';
  var ICON_SUCCESS = 'fas fa-check';
  var ATTR_TIMEOUT = 'timeout';
  var ATTR_TITLE_SUCCEED = 'data-title-succeed';
  var ATTR_TITLE_ORIGIN = 'data-bs-original-title';
  var TIMEOUT = 2000; // in milliseconds

  function isLocked(node) {
    if (node.hasAttribute(ATTR_TIMEOUT)) {
      var timeout = node.getAttribute(ATTR_TIMEOUT);
      if (Number(timeout) > Date.now()) {
        return true;
      }
    }
    return false;
  }
  function lock(node) {
    node.setAttribute(ATTR_TIMEOUT, Date.now() + TIMEOUT);
  }
  function unlock(node) {
    node.removeAttribute(ATTR_TIMEOUT);
  }
  function showTooltip(btn) {
    var succeedTitle = btn.getAttribute(ATTR_TITLE_SUCCEED);
    btn.setAttribute(ATTR_TITLE_ORIGIN, succeedTitle);
    Tooltip.getInstance(btn).show();
  }
  function hideTooltip(btn) {
    Tooltip.getInstance(btn).hide();
    btn.removeAttribute(ATTR_TITLE_ORIGIN);
  }
  function setSuccessIcon(btn) {
    var icon = btn.children[0];
    icon.setAttribute('class', ICON_SUCCESS);
  }
  function resumeIcon(btn) {
    var icon = btn.children[0];
    icon.setAttribute('class', ICON_DEFAULT);
  }
  function setCodeClipboard() {
    var clipboardList = document.querySelectorAll(clipboardSelector);
    if (clipboardList.length === 0) {
      return;
    }

    // Initial the clipboard.js object
    var clipboard = new ClipboardJS(clipboardSelector, {
      target: function target(trigger) {
        var codeBlock = trigger.parentNode.nextElementSibling;
        return codeBlock.querySelector('code .rouge-code');
      }
    });
    _toConsumableArray(clipboardList).map(function (elem) {
      return new Tooltip(elem, {
        placement: 'left'
      });
    });
    clipboard.on('success', function (e) {
      var trigger = e.trigger;
      e.clearSelection();
      if (isLocked(trigger)) {
        return;
      }
      setSuccessIcon(trigger);
      showTooltip(trigger);
      lock(trigger);
      setTimeout(function () {
        hideTooltip(trigger);
        resumeIcon(trigger);
        unlock(trigger);
      }, TIMEOUT);
    });
  }
  function setLinkClipboard() {
    var btnCopyLink = document.getElementById('copy-link');
    if (btnCopyLink === null) {
      return;
    }
    btnCopyLink.addEventListener('click', function (e) {
      var target = e.target;
      if (isLocked(target)) {
        return;
      }

      // Copy URL to clipboard
      navigator.clipboard.writeText(window.location.href).then(function () {
        var defaultTitle = target.getAttribute(ATTR_TITLE_ORIGIN);
        var succeedTitle = target.getAttribute(ATTR_TITLE_SUCCEED);

        // Switch tooltip title
        target.setAttribute(ATTR_TITLE_ORIGIN, succeedTitle);
        Tooltip.getInstance(target).show();
        lock(target);
        setTimeout(function () {
          target.setAttribute(ATTR_TITLE_ORIGIN, defaultTitle);
          unlock(target);
        }, TIMEOUT);
      });
    });
    btnCopyLink.addEventListener('mouseleave', function (e) {
      Tooltip.getInstance(e.target).hide();
    });
  }
  function initClipboard() {
    setCodeClipboard();
    setLinkClipboard();
  }

  /**
   * Setting up image lazy loading and LQIP switching
   */

  var ATTR_DATA_SRC = 'data-src';
  var ATTR_DATA_LQIP = 'data-lqip';
  var cover = {
    SHIMMER: 'shimmer',
    BLUR: 'blur'
  };
  function removeCover(clzss) {
    this.parentElement.classList.remove(clzss);
  }
  function handleImage() {
    if (!this.complete) {
      return;
    }
    if (this.hasAttribute(ATTR_DATA_LQIP)) {
      removeCover.call(this, cover.BLUR);
    } else {
      removeCover.call(this, cover.SHIMMER);
    }
  }

  /**
   * Switches the LQIP with the real image URL.
   */
  function switchLQIP() {
    var src = this.getAttribute(ATTR_DATA_SRC);
    this.setAttribute('src', encodeURI(src));
    this.removeAttribute(ATTR_DATA_SRC);
  }
  function loadImg() {
    var images = document.querySelectorAll('article img');
    if (images.length === 0) {
      return;
    }
    images.forEach(function (img) {
      img.addEventListener('load', handleImage);
    });

    // Images loaded from the browser cache do not trigger the 'load' event
    document.querySelectorAll('article img[loading="lazy"]').forEach(function (img) {
      if (img.complete) {
        removeCover.call(img, cover.SHIMMER);
      }
    });

    // LQIPs set by the data URI or WebP will not trigger the 'load' event,
    // so manually convert the URI to the URL of a high-resolution image.
    var lqips = document.querySelectorAll("article img[".concat(ATTR_DATA_LQIP, "=\"true\"]"));
    if (lqips.length) {
      lqips.forEach(function (lqip) {
        switchLQIP.call(lqip);
      });
    }
  }

  /**
   * Set up image popup
   *
   * Dependencies: https://github.com/biati-digital/glightbox
   */

  var lightImages = '.popup:not(.dark)';
  var darkImages = '.popup:not(.light)';
  var selector = lightImages;
  function updateImages(current, reverse) {
    if (selector === lightImages) {
      selector = darkImages;
    } else {
      selector = lightImages;
    }
    if (reverse === null) {
      reverse = GLightbox({
        selector: "".concat(selector)
      });
    }
    var _ref = [reverse, current];
    current = _ref[0];
    reverse = _ref[1];
  }
  function imgPopup() {
    if (document.querySelector('.popup') === null) {
      return;
    }
    var hasDualImages = !(document.querySelector('.popup.light') === null && document.querySelector('.popup.dark') === null);
    if (Theme.visualState === Theme.DARK) {
      selector = darkImages;
    }
    var current = GLightbox({
      selector: "".concat(selector)
    });
    if (hasDualImages && Theme.switchable) {
      var reverse = null;
      window.addEventListener('message', function (event) {
        if (event.source === window && event.data && event.data.id === Theme.ID) {
          updateImages(current, reverse);
        }
      });
    }
  }

  /**
   * Update month/day to locale datetime
   *
   * Requirement: <https://github.com/iamkun/dayjs>
   */
  /* A tool for locale datetime */
  var LocaleHelper = /*#__PURE__*/function () {
    function LocaleHelper() {
      _classCallCheck(this, LocaleHelper);
    }
    return _createClass(LocaleHelper, null, [{
      key: "attrTimestamp",
      get: function get() {
        return 'data-ts';
      }
    }, {
      key: "attrDateFormat",
      get: function get() {
        return 'data-df';
      }
    }, {
      key: "locale",
      get: function get() {
        return document.documentElement.getAttribute('lang').substring(0, 2);
      }
    }, {
      key: "getTimestamp",
      value: function getTimestamp(elem) {
        return Number(elem.getAttribute(this.attrTimestamp)); // unix timestamp
      }
    }, {
      key: "getDateFormat",
      value: function getDateFormat(elem) {
        return elem.getAttribute(this.attrDateFormat);
      }
    }]);
  }();
  function initLocaleDatetime() {
    dayjs.locale(LocaleHelper.locale);
    dayjs.extend(window.dayjs_plugin_localizedFormat);
    document.querySelectorAll("[".concat(LocaleHelper.attrTimestamp, "]")).forEach(function (elem) {
      var date = dayjs.unix(LocaleHelper.getTimestamp(elem));
      var text = date.format(LocaleHelper.getDateFormat(elem));
      elem.textContent = text;
      elem.removeAttribute(LocaleHelper.attrTimestamp);
      elem.removeAttribute(LocaleHelper.attrDateFormat);

      // setup tooltips
      if (elem.hasAttribute('data-bs-toggle') && elem.getAttribute('data-bs-toggle') === 'tooltip') {
        // see: https://day.js.org/docs/en/display/format#list-of-localized-formats
        var tooltipText = date.format('llll');
        elem.setAttribute('data-bs-title', tooltipText);
      }
    });
  }

  var _TocMobile;
  /**
   * TOC button, topbar and popup for mobile devices
   */

  var $tocBar = document.getElementById('toc-bar');
  var $soloTrigger = document.getElementById('toc-solo-trigger');
  var $triggers = document.getElementsByClassName('toc-trigger');
  var $popup = document.getElementById('toc-popup');
  var $btnClose = document.getElementById('toc-popup-close');
  var SCROLL_LOCK = 'overflow-hidden';
  var CLOSING = 'closing';
  var TocMobile = /*#__PURE__*/function () {
    function TocMobile() {
      _classCallCheck(this, TocMobile);
    }
    return _createClass(TocMobile, null, [{
      key: "initBar",
      value: function initBar() {
        var observer = new IntersectionObserver(function (entries) {
          entries.forEach(function (entry) {
            $tocBar.classList.toggle('invisible', entry.isIntersecting);
          });
        }, {
          rootMargin: "-".concat(_assertClassBrand(TocMobile, this, _barHeight)._, "px 0px 0px 0px")
        });
        observer.observe($soloTrigger);
        _invisible._ = _assertClassBrand(TocMobile, this, false);
      }
    }, {
      key: "listenAnchors",
      value: function listenAnchors() {
        var _this = this;
        var $anchors = document.getElementsByClassName('toc-link');
        _toConsumableArray($anchors).forEach(function (anchor) {
          anchor.onclick = function () {
            return _this.hidePopup();
          };
        });
      }
    }, {
      key: "refresh",
      value: function refresh() {
        if (_assertClassBrand(TocMobile, this, _invisible)._) {
          this.initComponents();
        }
        tocbot.refresh(this.options);
        this.listenAnchors();
      }
    }, {
      key: "popupOpened",
      get: function get() {
        return $popup.open;
      }
    }, {
      key: "showPopup",
      value: function showPopup() {
        this.lockScroll(true);
        $popup.showModal();
        var activeItem = $popup.querySelector('li.is-active-li');
        activeItem.scrollIntoView({
          block: 'center'
        });
      }
    }, {
      key: "hidePopup",
      value: function hidePopup() {
        $popup.toggleAttribute(CLOSING);
        $popup.addEventListener('animationend', function () {
          $popup.toggleAttribute(CLOSING);
          $popup.close();
        }, {
          once: true
        });
        this.lockScroll(false);
      }
    }, {
      key: "lockScroll",
      value: function lockScroll(enable) {
        document.documentElement.classList.toggle(SCROLL_LOCK, enable);
        document.body.classList.toggle(SCROLL_LOCK, enable);
      }
    }, {
      key: "clickBackdrop",
      value: function clickBackdrop(event) {
        if ($popup.hasAttribute(CLOSING)) {
          return;
        }
        var rect = event.target.getBoundingClientRect();
        if (event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom) {
          this.hidePopup();
        }
      }
    }, {
      key: "initComponents",
      value: function initComponents() {
        var _this2 = this;
        this.initBar();
        _toConsumableArray($triggers).forEach(function (trigger) {
          trigger.onclick = function () {
            return _this2.showPopup();
          };
        });
        $popup.onclick = function (e) {
          return _this2.clickBackdrop(e);
        };
        $btnClose.onclick = function () {
          return _this2.hidePopup();
        };
        $popup.oncancel = function (e) {
          e.preventDefault();
          _this2.hidePopup();
        };
      }
    }, {
      key: "init",
      value: function init() {
        tocbot.init(this.options);
        this.listenAnchors();
        this.initComponents();
      }
    }]);
  }();
  _TocMobile = TocMobile;
  var _invisible = {
    _: true
  };
  var _barHeight = {
    _: 16 * 3
  };
  // 3rem
  _defineProperty(TocMobile, "options", {
    tocSelector: '#toc-popup-content',
    contentSelector: '.content',
    ignoreSelector: '[data-toc-skip]',
    headingSelector: 'h2, h3, h4',
    orderedList: false,
    scrollSmooth: false,
    collapseDepth: 4,
    headingsOffset: _assertClassBrand(_TocMobile, _TocMobile, _barHeight)._
  });

  var TocDesktop = /*#__PURE__*/function () {
    function TocDesktop() {
      _classCallCheck(this, TocDesktop);
    }
    return _createClass(TocDesktop, null, [{
      key: "refresh",
      value: function refresh() {
        tocbot.refresh(this.options);
      }
    }, {
      key: "init",
      value: function init() {
        tocbot.init(this.options);
      }
    }]);
  }();
  /* Tocbot options Ref: https://github.com/tscanlin/tocbot#usage */
  _defineProperty(TocDesktop, "options", {
    tocSelector: '#toc',
    contentSelector: '.content',
    ignoreSelector: '[data-toc-skip]',
    headingSelector: 'h2, h3, h4',
    orderedList: false,
    scrollSmooth: false,
    headingsOffset: 16 * 2 // 2rem
  });

  var desktopMode = matchMedia('(min-width: 1200px)');
  function refresh(e) {
    if (e.matches) {
      if (TocMobile.popupOpened) {
        TocMobile.hidePopup();
      }
      TocDesktop.refresh();
    } else {
      TocMobile.refresh();
    }
  }
  function init() {
    if (document.querySelector('main>article[data-toc="true"]') === null) {
      return;
    }

    // Avoid create multiple instances of Tocbot. Ref: <https://github.com/tscanlin/tocbot/issues/203>
    if (desktopMode.matches) {
      TocDesktop.init();
    } else {
      TocMobile.init();
    }
    var $tocWrapper = document.getElementById('toc-wrapper');
    $tocWrapper.classList.remove('invisible');
    desktopMode.onchange = refresh;
  }

  /**
   * Mermaid-js loader
   */

  var MERMAID = 'mermaid';
  var themeMapper = Theme.getThemeMapper('default', 'dark');
  function refreshTheme(event) {
    if (event.source === window && event.data && event.data.id === Theme.ID) {
      // Re-render the SVG âº <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344>
      var mermaidList = document.getElementsByClassName(MERMAID);
      _toConsumableArray(mermaidList).forEach(function (elem) {
        var svgCode = elem.previousSibling.children.item(0).textContent;
        elem.textContent = svgCode;
        elem.removeAttribute('data-processed');
      });
      var newTheme = themeMapper[Theme.visualState];
      mermaid.initialize({
        theme: newTheme
      });
      mermaid.init(null, ".".concat(MERMAID));
    }
  }
  function setNode(elem) {
    var svgCode = elem.textContent;
    var backup = elem.parentElement;
    backup.classList.add('d-none');
    // Create mermaid node
    var mermaid = document.createElement('pre');
    mermaid.classList.add(MERMAID);
    var text = document.createTextNode(svgCode);
    mermaid.appendChild(text);
    backup.after(mermaid);
  }
  function loadMermaid() {
    if (typeof mermaid === 'undefined' || typeof mermaid.initialize !== 'function') {
      return;
    }
    var initTheme = themeMapper[Theme.visualState];
    var mermaidConf = {
      theme: initTheme
    };
    var basicList = document.getElementsByClassName('language-mermaid');
    _toConsumableArray(basicList).forEach(setNode);
    mermaid.initialize(mermaidConf);
    if (Theme.switchable) {
      window.addEventListener('message', refreshTheme);
    }
  }

  /**
   * Add listener for theme mode toggle
   */

  var $toggle = document.getElementById('mode-toggle');
  function modeWatcher() {
    if (!$toggle) {
      return;
    }
    $toggle.addEventListener('click', function () {
      Theme.flip();
    });
  }

  /**
   * Reference: https://bootsnipp.com/snippets/featured/link-to-top-page
   */

  function back2top() {
    var btn = document.getElementById('back-to-top');
    window.addEventListener('scroll', function () {
      if (window.scrollY > 50) {
        btn.classList.add('show');
      } else {
        btn.classList.remove('show');
      }
    });
    btn.addEventListener('click', function () {
      window.scrollTo({
        top: 0
      });
    });
  }

  function loadTooptip() {
    var tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    _toConsumableArray(tooltipTriggerList).map(function (tooltipTriggerEl) {
      return new Tooltip(tooltipTriggerEl);
    });
  }

  function basic() {
    modeWatcher();
    back2top();
    loadTooptip();
  }

  var ATTR_DISPLAY = 'sidebar-display';
  var $sidebar = document.getElementById('sidebar');
  var $trigger = document.getElementById('sidebar-trigger');
  var $mask = document.getElementById('mask');
  var SidebarUtil = /*#__PURE__*/function () {
    function SidebarUtil() {
      _classCallCheck(this, SidebarUtil);
    }
    return _createClass(SidebarUtil, null, [{
      key: "toggle",
      value: function toggle() {
        _isExpanded._ = _assertClassBrand(SidebarUtil, this, !_assertClassBrand(SidebarUtil, this, _isExpanded)._);
        document.body.toggleAttribute(ATTR_DISPLAY, _assertClassBrand(SidebarUtil, this, _isExpanded)._);
        $sidebar.classList.toggle('z-2', _assertClassBrand(SidebarUtil, this, _isExpanded)._);
        $mask.classList.toggle('d-none', !_assertClassBrand(SidebarUtil, this, _isExpanded)._);
      }
    }]);
  }();
  var _isExpanded = {
    _: false
  };
  function initSidebar() {
    $trigger.onclick = $mask.onclick = function () {
      return SidebarUtil.toggle();
    };
  }

  /**
   * This script make #search-result-wrapper switch to unload or shown automatically.
   */

  var btnSbTrigger = document.getElementById('sidebar-trigger');
  var btnSearchTrigger = document.getElementById('search-trigger');
  var btnCancel = document.getElementById('search-cancel');
  var content = document.querySelectorAll('#main-wrapper>.container>.row');
  var topbarTitle = document.getElementById('topbar-title');
  var search = document.getElementById('search');
  var resultWrapper = document.getElementById('search-result-wrapper');
  var results = document.getElementById('search-results');
  var input = document.getElementById('search-input');
  var hints = document.getElementById('search-hints');

  // CSS class names
  var LOADED = 'd-block';
  var UNLOADED = 'd-none';
  var FOCUS = 'input-focus';
  var FLEX = 'd-flex';

  /* Actions in mobile screens (Sidebar hidden) */
  var MobileSearchBar = /*#__PURE__*/function () {
    function MobileSearchBar() {
      _classCallCheck(this, MobileSearchBar);
    }
    return _createClass(MobileSearchBar, null, [{
      key: "on",
      value: function on() {
        btnSbTrigger.classList.add(UNLOADED);
        topbarTitle.classList.add(UNLOADED);
        btnSearchTrigger.classList.add(UNLOADED);
        search.classList.add(FLEX);
        btnCancel.classList.add(LOADED);
      }
    }, {
      key: "off",
      value: function off() {
        btnCancel.classList.remove(LOADED);
        search.classList.remove(FLEX);
        btnSbTrigger.classList.remove(UNLOADED);
        topbarTitle.classList.remove(UNLOADED);
        btnSearchTrigger.classList.remove(UNLOADED);
      }
    }]);
  }();
  var ResultSwitch = /*#__PURE__*/function () {
    function ResultSwitch() {
      _classCallCheck(this, ResultSwitch);
    }
    return _createClass(ResultSwitch, null, [{
      key: "on",
      value: function on() {
        if (!this.resultVisible) {
          resultWrapper.classList.remove(UNLOADED);
          content.forEach(function (el) {
            el.classList.add(UNLOADED);
          });
          this.resultVisible = true;
        }
      }
    }, {
      key: "off",
      value: function off() {
        if (this.resultVisible) {
          results.innerHTML = '';
          if (hints.classList.contains(UNLOADED)) {
            hints.classList.remove(UNLOADED);
          }
          resultWrapper.classList.add(UNLOADED);
          content.forEach(function (el) {
            el.classList.remove(UNLOADED);
          });
          input.textContent = '';
          this.resultVisible = false;
        }
      }
    }]);
  }();
  _defineProperty(ResultSwitch, "resultVisible", false);
  function isMobileView() {
    return btnCancel.classList.contains(LOADED);
  }
  function displaySearch() {
    btnSearchTrigger.addEventListener('click', function () {
      MobileSearchBar.on();
      ResultSwitch.on();
      input.focus();
    });
    btnCancel.addEventListener('click', function () {
      MobileSearchBar.off();
      ResultSwitch.off();
    });
    input.addEventListener('focus', function () {
      search.classList.add(FOCUS);
    });
    input.addEventListener('focusout', function () {
      search.classList.remove(FOCUS);
    });
    input.addEventListener('input', function () {
      if (input.value === '') {
        if (isMobileView()) {
          hints.classList.remove(UNLOADED);
        } else {
          ResultSwitch.off();
        }
      } else {
        ResultSwitch.on();
        if (isMobileView()) {
          hints.classList.add(UNLOADED);
        }
      }
    });
  }

  function initTopbar() {
    displaySearch();
  }

  loadImg();
  init();
  imgPopup();
  initSidebar();
  initLocaleDatetime();
  initClipboard();
  initTopbar();
  loadMermaid();
  basic();

})(null, Tooltip);
//# sourceMappingURL=post.min.js.map
